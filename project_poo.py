# -*- coding: utf-8 -*-
"""project_poo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/R5780/09159bccfc2381494cdd805cf283b48e/project_poo.ipynb
"""

from google.colab import files
uploaded = files.upload()

class DNASequence:
    def __init__(self, sequence, label=None):
        self.sequence = sequence.replace('\t', '')
        self.label = label
        self.encoded = None

    def one_hot_encode(self):
        mapping = {
            'A': [1, 0, 0, 0],
            'C': [0, 1, 0, 0],
            'G': [0, 0, 1, 0],
            'T': [0, 0, 0, 1]
        }
        self.encoded = []
        for nucleotide in self.sequence:
            self.encoded.extend(mapping.get(nucleotide, [0, 0, 0, 0]))
        return self.encoded

    def __str__(self):
        return f"DNASequence(sequence={self.sequence[:10]}..., label={self.label})"

import pandas as pd

# Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„Ù CSV
df = pd.read_csv("dna_sequences.csv")

# Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø´ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
print(df.head())

# ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ ØµÙ Ø¥Ù„Ù‰ ÙƒØ§Ø¦Ù† Ù…Ù† Ù†ÙˆØ¹ DNASequence
sequences = []
for i, row in df.iterrows():
    seq_str = ''.join(map(str, row[:-1]))
    label = row["Class"]
    seq_obj = DNASequence(seq_str, label)
    seq_obj.one_hot_encode()
    sequences.append(seq_obj)

print(f"Ø¹Ø¯Ø¯ Ø§Ù„ØªØ³Ù„Ø³Ù„Ø§Øª: {len(sequences)}")
print(sequences[0])

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, accuracy_score
import numpy as np

# ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
X = np.array([s.encoded for s in sequences])
y = np.array([1 if s.label == '+' else 0 for s in sequences])

# ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)

# ØªØ¯Ø±ÙŠØ¨ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬
model = RandomForestClassifier()
model.fit(X_train, y_train)

# Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
y_pred = model.predict(X_test)
print("Accuracy:", accuracy_score(y_test, y_pred))
print(classification_report(y_test, y_pred))

import seaborn as sns
import matplotlib.pyplot as plt

sns.countplot(x="Class", data=df)
plt.title("RÃ©partition des classes")
plt.xlabel("Classe")
plt.ylabel("Nombre de sÃ©quences")
plt.show()

"""# Projet de Classification de SÃ©quences ADN

## ğŸ¯ Objectif
Ce projet a pour but d'analyser des sÃ©quences d'ADN et de prÃ©dire si elles sont des **promoteurs** ou non, en utilisant des algorithmes de Machine Learning et la programmation orientÃ©e objet (POO) en Python.

## ğŸ§¬ DonnÃ©es utilisÃ©es
Les donnÃ©es proviennent de [UCI Machine Learning Repository](https://archive.ics.uci.edu/ml/datasets/Molecular+Biology+(Promoter+Gene+Sequences)).  
Elles contiennent **100 sÃ©quences ADN**, chacune de **57 nuclÃ©otides**, avec un label :
- `+` pour promoteur
- `-` pour non-promoteur

## âš™ï¸ Structure du projet
- `DNASequence` : une classe qui reprÃ©sente une sÃ©quence ADN avec encodage numÃ©rique.
- `ModelTrainer` (dans Colab) : pour entraÃ®ner et Ã©valuer des modÃ¨les de classification.
- `main` : exÃ©cution de lâ€™analyse complÃ¨te dans Google Colab.

## ğŸ§ª MÃ©thodologie
- Importation et nettoyage des donnÃ©es
- One-hot encoding des sÃ©quences
- EntraÃ®nement de modÃ¨les (Random Forest)
- Ã‰valuation par prÃ©cision et rapport de classification

## ğŸ“Š RÃ©sultats
Le modÃ¨le Random Forest a obtenu une prÃ©cision dâ€™environ **XX%** (Ã  complÃ©ter aprÃ¨s exÃ©cution).  
Les rÃ©sultats montrent que les sÃ©quences promoteurs ont un certain motif distinctif captÃ© par le modÃ¨le.

## ğŸ“ Fichiers fournis
- `dna_sequences.csv` : fichier CSV nettoyÃ©
- Code complet dans un notebook `.ipynb`

## ğŸš€ ExÃ©cution
Ce projet a Ã©tÃ© rÃ©alisÃ© entiÃ¨rement dans **Google Colab**.

"""